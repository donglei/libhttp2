module libhttp2.helpers;

import libhttp2.types : Token;
import std.bitmanip : bigEndianToNative, nativeToBigEndian;
import libhttp2.types : HeaderField, Setting, Mem;
import std.c.string : memcpy;
import std.string : toLowerInPlace;

void write(T)(out ubyte* buf, T n) {
	auto x = nativeToBigEndian(n);
	memcpy(buf.ptr, x.ptr, T.sizeof);
}

T read(T = uint)(in ubyte* buf) {
	return bigEndianToNative(buf[0 .. T.sizeof]);
}


HeaderField[] copy(ref HeaderField[] hfa) {
	if (hfa.length == 0)
		return null;

	HeaderField[] ret = Mem.alloc!(HeaderField[])(hfa.length);

	foreach (size_t i, ref HeaderField hf; hfa) {
		ret[i].flag = hf.flag;
		ret[i].name = Mem.copy(hf.name);
		toLowerInPlace(ret[i].name);
		ret[i].value = Mem.copy(hf.value);
	}
	return ret;
}

/*
 * Makes copy of |iv| and return the copy. This function returns the 
 * copy if it succeeds, or null.
 */
Setting[] copy(in Setting[] iv) {
	if (iv.length == 0)
		return null;

	return Mem.copy(iv);
}

/*
 * This function was generated by genlibtokenlookup.py.  Inspired by
 * h2o header lookup.  https://github.com/h2o/h2o
 */
Token parseToken(in ubyte[] name) {
	with(Token) switch (name.length) {
		case 2:
			switch (name[$ - 1]) {
				case 'e':
					if (name[0] == 't') {
						return TE;
					}
					break;
			}
			break;
		case 4:
			switch (name[$ - 1]) {
				case 't':
					if (name.ptr[0 .. 3] == "hos") {
						return HOST;
					}
					break;
			}
			break;
		case 5:
			switch (name[$ - 1]) {
				case 'h':
					if (name.ptr[0 .. 4] == ":pat") {
						return _PATH;
					}
					break;
			}
			break;
		case 7:
			switch (name[$ - 1]) {
				case 'd':
					if (name.ptr[0 .. 6] == ":metho") {
						return _METHOD;
					}
					break;
				case 'e':
					if (name.ptr[0 .. 6] == ":schem") {
						return _SCHEME;
					}
					if (name.ptr[0 .. 6] == "upgrad") {
						return UPGRADE;
					}
					break;
				case 's':
					if (name.ptr[0 .. 6] == ":statu") {
						return _STATUS;
					}
					break;
			}
			break;
		case 10:
			switch (name[$ - 1]) {
				case 'e':
					if (name.ptr[0 .. 9] == "keep-aliv") {
						return KEEP_ALIVE;
					}
					break;
				case 'n':
					if (name.ptr[0 .. 9] == "connectio") {
						return CONNECTION;
					}
					break;
				case 'y':
					if (name.ptr[0 .. 9] == ":authorit") {
						return _AUTHORITY;
					}
					break;
			}
			break;
		case 14:
			switch (name[$ - 1]) {
				case 'h':
					if (name.ptr[0 .. 13] == "content-lengt") {
						return CONTENT_LENGTH;
					}
					break;
			}
			break;
		case 16:
			switch (name[$ - 1]) {
				case 'n':
					if (name.ptr[0 .. 15] == "proxy-connectio") {
						return PROXY_CONNECTION;
					}
					break;
			}
			break;
		case 17:
			switch (name[$ - 1]) {
				case 'g':
					if (name.ptr[0 .. 16] == "transfer-encodin") {
						return TRANSFER_ENCODING;
					}
					break;
			}
			break;
	}
	return Token.UNKNOWN;
}