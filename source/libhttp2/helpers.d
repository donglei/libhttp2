module libhttp2.helpers;

import libhttp2.constants;
import std.bitmanip : bigEndianToNative, nativeToBigEndian;
import libhttp2.types : Token, HeaderField, Setting, Mem, ErrorCode;
import std.c.string : memcpy;
import std.string : toLowerInPlace;
import core.exception : onRangeError;
import std.algorithm : max, min;

void write(T)(out ubyte* buf, T n) {
	auto x = nativeToBigEndian(n);
	memcpy(buf.ptr, x.ptr, T.sizeof);
}

void write(T)(out ubyte[] buf, T n) {
	if (buf.length < n) onRangeError();
	auto x = nativeToBigEndian(n);
	memcpy(buf.ptr, x.ptr, T.sizeof);
}

T read(T = uint)(in ubyte* buf) {
	return bigEndianToNative!T(buf[0 .. T.sizeof]);
}

T read(T = uint)(in ubyte[] buf) {
	if (buf.length < T.sizeof) onRangeError();
	return bigEndianToNative!T(buf);
}

HeaderField[] copy(ref HeaderField[] hfa) {
	if (hfa.length == 0)
		return null;

	HeaderField[] ret = Mem.alloc!(HeaderField[])(hfa.length);

	foreach (size_t i, ref HeaderField hf; hfa) {
		ret[i].flag = hf.flag;
		ret[i].name = Mem.copy(hf.name);
		toLowerInPlace(ret[i].name);
		ret[i].value = Mem.copy(hf.value);
	}
	return ret;
}

/*
 * Makes copy of |iv| and return the copy. This function returns the 
 * copy if it succeeds, or null.
 */
Setting[] copy(in Setting[] iv) {
	if (iv.length == 0)
		return null;

	return Mem.copy(iv);
}


bool equals(HeaderField[] hfa, HeaderField[] other) 
{
	auto hfa2 = hfa.copy();
	auto other2 = other.copy();
	scope(exit) {
		Mem.free(hfa2);
		Mem.free(other2);
	}
	hfa2.sort();
	other2.sort();
	foreach(i, hf; hfa2)
		if (other2[i] != hf)
			return false;
	return true;
}


/*
 * This function was generated by genlibtokenlookup.py.  Inspired by
 * h2o header lookup.  https://github.com/h2o/h2o
 */
Token parseToken(in ubyte[] name) {
	with(Token) switch (name.length) {
		case 2:
			switch (name[$ - 1]) {
				case 'e':
					if (name[0] == 't') {
						return TE;
					}
					break;
			}
			break;
		case 4:
			switch (name[$ - 1]) {
				case 't':
					if (name.ptr[0 .. 3] == "hos") {
						return HOST;
					}
					break;
			}
			break;
		case 5:
			switch (name[$ - 1]) {
				case 'h':
					if (name.ptr[0 .. 4] == ":pat") {
						return _PATH;
					}
					break;
			}
			break;
		case 7:
			switch (name[$ - 1]) {
				case 'd':
					if (name.ptr[0 .. 6] == ":metho") {
						return _METHOD;
					}
					break;
				case 'e':
					if (name.ptr[0 .. 6] == ":schem") {
						return _SCHEME;
					}
					if (name.ptr[0 .. 6] == "upgrad") {
						return UPGRADE;
					}
					break;
				case 's':
					if (name.ptr[0 .. 6] == ":statu") {
						return _STATUS;
					}
					break;
			}
			break;
		case 10:
			switch (name[$ - 1]) {
				case 'e':
					if (name.ptr[0 .. 9] == "keep-aliv") {
						return KEEP_ALIVE;
					}
					break;
				case 'n':
					if (name.ptr[0 .. 9] == "connectio") {
						return CONNECTION;
					}
					break;
				case 'y':
					if (name.ptr[0 .. 9] == ":authorit") {
						return _AUTHORITY;
					}
					break;
			}
			break;
		case 14:
			switch (name[$ - 1]) {
				case 'h':
					if (name.ptr[0 .. 13] == "content-lengt") {
						return CONTENT_LENGTH;
					}
					break;
			}
			break;
		case 16:
			switch (name[$ - 1]) {
				case 'n':
					if (name.ptr[0 .. 15] == "proxy-connectio") {
						return PROXY_CONNECTION;
					}
					break;
			}
			break;
		case 17:
			switch (name[$ - 1]) {
				case 'g':
					if (name.ptr[0 .. 16] == "transfer-encodin") {
						return TRANSFER_ENCODING;
					}
					break;
			}
			break;
	}
	return Token.UNKNOWN;
}


/*
 *   local_window_size
 *   ^  *
 *   |  *    recv_window_size
 *   |  *  * ^
 *   |  *  * |
 *  0+++++++++
 *   |  *  *   \
 *   |  *  *   | This rage is hidden in flow control.  But it must be
 *   v  *  *   / kept in order to restore it when window size is enlarged.
 *   recv_reduction
 *   (+ for negative direction)
 *
 *   recv_window_size could be negative if we decrease
 *   local_window_size more than recv_window_size:
 *
 *   local_window_size
 *   ^  *
 *   |  *
 *   |  *
 *   0++++++++
 *   |  *    ^ recv_window_size (negative)
 *   |  *    |
 *   v  *  *
 *   recv_reduction
 */
ErrorCode adjustLocalWindowSize(ref int local_window_size_ptr, ref int recv_window_size_ptr, ref int recv_reduction_ptr, ref int delta_ptr)
{
	if (delta_ptr > 0) {
		int recv_reduction_delta;
		int delta;
		int new_recv_window_size = max(0, recv_window_size_ptr) - delta_ptr;
		
		if (new_recv_window_size >= 0) 
		{
			recv_window_size_ptr = new_recv_window_size;
			return 0;
		}
		
		delta = -new_recv_window_size;
		
		/* The delta size is strictly more than received bytes. Increase
       	   local_window_size by that difference |delta|. */
		if (local_window_size_ptr > MAX_WINDOW_SIZE - delta)
		{
			return ErrorCode.FLOW_CONTROL;
		}
		local_window_size_ptr += delta;

		/* If there is recv_reduction due to earlier window_size
       	   reduction, we have to adjust it too. */
		recv_reduction_delta = min(recv_reduction_ptr, delta);

		recv_reduction_ptr -= recv_reduction_delta;

		if (recv_window_size_ptr < 0) {
			recv_window_size_ptr += recv_reduction_delta;
		} else {
			/* If recv_window_size_ptr > 0, then those bytes are going to
		       be returned to the remote peer (by WINDOW_UPDATE with the
		       adjusted delta_ptr), so it is effectively 0 now.  We set to
		       recv_reduction_delta, because caller does not take into
		       account it in delta_ptr. */
			recv_window_size_ptr = recv_reduction_delta;
		}

		/* recv_reduction_delta must be paied from delta_ptr, since it
       	   was added in window size reduction (see below). */
		delta_ptr -= recv_reduction_delta;
		
		return 0;
	}

	if (local_window_size_ptr + delta_ptr < 0 ||
		recv_window_size_ptr < int.min - delta_ptr ||
		recv_reduction_ptr > int.max + delta_ptr)
	{
		return ErrorCode.FLOW_CONTROL;
	}
	/* Decreasing local window size. Note that we achieve this without
	   noticing to the remote peer. To do this, we cut
	   recv_window_size by -delta. This means that we don't send
	   WINDOW_UPDATE for -delta bytes. */

	local_window_size_ptr += delta_ptr;
	recv_window_size_ptr += delta_ptr;
	recv_reduction_ptr -= delta_ptr;
	delta_ptr = 0;
	
	return 0;
}

bool shouldSendWindowUpdate(int local_window_size, int recv_window_size) {
	return recv_window_size >= local_window_size / 2;
}